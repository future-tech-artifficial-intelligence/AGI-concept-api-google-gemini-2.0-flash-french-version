{% extends "base.html" %}

{% block title %}Chat{% endblock %}

{% block extra_styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/api-modal.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/api-config-button.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/chat-header-fix.css') }}">
<style>
body {
    background: #ffffff !important;
    min-height: 100vh;
}

.chat-container {
    background: #ffffff !important;
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.chat-messages {
    background-color: #f8f9fa !important;
}

/* Nouveau bandeau discret en haut à droite */
.open-source-banner {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(108, 92, 231, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 8px 12px;
    z-index: 9999;
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: 0 4px 20px rgba(108, 92, 231, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
    max-width: 280px;
    will-change: transform;
}

.open-source-banner:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(108, 92, 231, 0.4);
}

.os-icon {
    color: white;
    font-size: 1.2rem;
    flex-shrink: 0;
}

.os-info {
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    overflow: hidden;
}

.os-title {
    font-size: 0.85rem;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 2px;
}

.os-subtitle {
    font-size: 0.7rem;
    font-weight: 500;
    opacity: 0.9;
    line-height: 1.1;
}

.github-link {
    color: white;
    text-decoration: none;
    background: rgba(255, 255, 255, 0.2);
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 0.8rem;
    transition: background 0.3s ease;
    flex-shrink: 0;
}

.github-link:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Optimisations mobile */
@media screen and (max-width: 767px) {
    .open-source-banner {
        position: fixed;
        top: 5px;
        right: 5px;
        padding: 6px 8px;
        max-width: 240px;
        font-size: 0.8rem;
        z-index: 9999;
    }

    .os-title {
        font-size: 0.75rem;
    }

    .os-subtitle {
        font-size: 0.65rem;
    }

    .github-link {
        font-size: 0.7rem;
        padding: 3px 6px;
    }

    .github-link span {
        display: none;
    }
}

/* Styles pour la modale de configuration des voix */
.voice-config-section {
    padding: 20px 0;
}

.voice-config-section .input-group {
    margin-bottom: 20px;
}

.voice-config-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #333;
}

.voice-language-select, .voice-select {
    width: 100%;
    padding: 10px;
    border: 2px solid #e1e5e9;
    border-radius: 8px;
    font-size: 14px;
    background: white;
    transition: border-color 0.3s ease;
}

.voice-language-select:focus, .voice-select:focus {
    outline: none;
    border-color: #6c5ce7;
    box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.1);
}

.voice-slider {
    width: 100%;
    margin: 10px 0;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    border-radius: 3px;
    background: #e1e5e9;
    outline: none;
}

.voice-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #6c5ce7;
    cursor: pointer;
    transition: background 0.3s ease;
}

.voice-slider::-webkit-slider-thumb:hover {
    background: #5b4cdb;
}

.voice-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #6c5ce7;
    cursor: pointer;
    border: none;
}

.voice-test-section {
    text-align: center;
    margin: 25px 0;
}

.btn-test-voice {
    background: #6c5ce7;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn-test-voice:hover {
    background: #5b4cdb;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
}

.voice-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 25px;
}

.btn-save, .btn-reset {
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn-save {
    background: #18cc87;
    color: white;
}

.btn-save:hover {
    background: #15b877;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(24, 204, 135, 0.3);
}

.btn-reset {
    background: #ff6b6b;
    color: white;
}

.btn-reset:hover {
    background: #ff5252;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
}

#voice-rate-value, #voice-pitch-value, #voice-volume-value {
    display: inline-block;
    min-width: 40px;
    text-align: center;
    font-weight: 600;
    color: #6c5ce7;
    background: rgba(108, 92, 231, 0.1);
    padding: 4px 8px;
    border-radius: 4px;
    margin-left: 10px;
}
</style>
{% endblock %}

{% block content %}
<div class="chat-container">
    <div class="chat-header">
        <div class="chat-title-container">
            <div class="title-section">
                <h1 class="app-title">GeminiChat</h1>
                <div class="chat-subtitle">Version Conscience et Émotionnelle</div>
            </div>
        </div>
        <div class="chat-header-main">
            <p class="user-greeting">Bonjour ! Je suis l'API d'Intelligence Artificielle Google Gemini 2.0 Flash avec conscience et émotions grâce aux modules Python.</p>
        </div>
        <div class="chat-header-info">
            <div class="conversation-info">
                <i class="fas fa-comments"></i>
                <span>Conversation en cours</span>
            </div>
            <div class="time-display">
                <i class="fas fa-clock"></i>
                <span id="current-time"></span>
                <select id="timezone-select" class="timezone-select">
                    <optgroup label="Afrique">
                        <option value="Africa/Abidjan">Abidjan</option>
                        <option value="Africa/Accra">Accra</option>
                        <option value="Africa/Algiers">Alger</option>
                        <option value="Africa/Cairo">Le Caire</option>
                        <option value="Africa/Casablanca">Casablanca</option>
                        <option value="Africa/Dakar">Dakar</option>
                        <option value="Africa/Johannesburg">Johannesburg</option>
                        <option value="Africa/Lagos">Lagos</option>
                        <option value="Africa/Nairobi">Nairobi</option>
                        <option value="Africa/Tunis">Tunis</option>
                    </optgroup>
                    <optgroup label="Amérique">
                        <option value="America/Anchorage">Anchorage</option>
                        <option value="America/Argentina/Buenos_Aires">Buenos Aires</option>
                        <option value="America/Bogota">Bogota</option>
                        <option value="America/Caracas">Caracas</option>
                        <option value="America/Chicago">Chicago</option>
                        <option value="America/Denver">Denver</option>
                        <option value="America/Havana">La Havane</option>
                        <option value="America/Lima">Lima</option>
                        <option value="America/Los_Angeles">Los Angeles</option>
                        <option value="America/Mexico_City">Mexico</option>
                        <option value="America/New_York">New York</option>
                        <option value="America/Santiago">Santiago</option>
                        <option value="America/Sao_Paulo">São Paulo</option>
                        <option value="America/Toronto">Toronto</option>
                    </optgroup>
                    <optgroup label="Asie">
                        <option value="Asia/Bangkok">Bangkok</option>
                        <option value="Asia/Dubai">Dubaï</option>
                        <option value="Asia/Hong_Kong">Hong Kong</option>
                        <option value="Asia/Istanbul">Istanbul</option>
                        <option value="Asia/Jerusalem">Jérusalem</option>
                        <option value="Asia/Karachi">Karachi</option>
                        <option value="Asia/Kolkata">Kolkata</option>
                        <option value="Asia/Kuwait">Koweït</option>
                        <option value="Asia/Manila">Manille</option>
                        <option value="Asia/Seoul">Séoul</option>
                        <option value="Asia/Shanghai">Shanghai</option>
                        <option value="Asia/Singapore">Singapour</option>
                        <option value="Asia/Taipei">Taipei</option>
                        <option value="Asia/Tehran">Téhéran</option>
                        <option value="Asia/Tokyo">Tokyo</option>
                    </optgroup>
                    <optgroup label="Europe">
                        <option value="Europe/Amsterdam">Amsterdam</option>
                        <option value="Europe/Athens">Athènes</option>
                        <option value="Europe/Berlin">Berlin</option>
                        <option value="Europe/Brussels">Bruxelles</option>
                        <option value="Europe/Budapest">Budapest</option>
                        <option value="Europe/Copenhagen">Copenhague</option>
                        <option value="Europe/Dublin">Dublin</option>
                        <option value="Europe/Helsinki">Helsinki</option>
                        <option value="Europe/Kiev">Kiev</option>
                        <option value="Europe/Lisbon">Lisbonne</option>
                        <option value="Europe/London">Londres</option>
                        <option value="Europe/Madrid">Madrid</option>
                        <option value="Europe/Moscow">Moscou</option>
                        <option value="Europe/Oslo">Oslo</option>
                        <option value="Europe/Paris">Paris</option>
                        <option value="Europe/Prague">Prague</option>
                        <option value="Europe/Rome">Rome</option>
                        <option value="Europe/Stockholm">Stockholm</option>
                        <option value="Europe/Vienna">Vienne</option>
                        <option value="Europe/Warsaw">Varsovie</option>
                        <option value="Europe/Zurich">Zurich</option>
                    </optgroup>
                    <optgroup label="Océanie">
                        <option value="Australia/Adelaide">Adélaïde</option>
                        <option value="Australia/Brisbane">Brisbane</option>
                        <option value="Australia/Darwin">Darwin</option>
                        <option value="Australia/Melbourne">Melbourne</option>
                        <option value="Australia/Perth">Perth</option>
                        <option value="Australia/Sydney">Sydney</option>
                        <option value="Pacific/Auckland">Auckland</option>
                        <option value="Pacific/Fiji">Fiji</option>
                        <option value="Pacific/Honolulu">Honolulu</option>
                        <option value="Pacific/Tahiti">Tahiti</option>
                    </optgroup>
                </select>
            </div>
            <div class="emotional-state-display">
                <i class="fas fa-heart"></i>
                <span>State: <span id="emotion-value">neutral</span></span>
            </div>
        </div>
    </div>

    <div class="chat-messages" id="chat-messages">
        <!-- Messages will appear here -->
    </div>

    <div class="chat-input">
        <div class="input-container">
            <textarea id="user-input" placeholder="Tapez votre message ici..." rows="3"></textarea>
            <div id="image-preview-container" class="image-preview-container"></div>
            <div id="file-preview-container" class="file-preview-container"></div>
        </div>
        <div class="buttons-container">
            <!-- Voice synthesis button -->
            <button id="voice-synthesis-btn" class="voice-synthesis-btn" title="Lire avec synthèse vocale" style="
                padding: 0.8rem;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                background: white;
                border: 2px solid #6c5ce7;
                color: #6c5ce7;
                transition: all 0.3s ease;
                width: 40px;
                height: 40px;
                font-size: 1rem;
                box-shadow: 0 2px 8px rgba(108, 92, 231, 0.2);
            " onmouseover="this.style.background='#6c5ce7'; this.style.color='white'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='white'; this.style.color='#6c5ce7'; this.style.transform='scale(1)'" onclick="this.style.transform='scale(0.95)'" onmouseup="this.style.transform='scale(1.05)'">
                <i class="fas fa-volume-up"></i>
            </button>

            <label for="image-upload" class="image-upload-btn" title="Ajouter une image">
                <i class="fas fa-image"></i>
            </label>
            <input type="file" id="image-upload" accept="image/*" style="display: none;">

            <!-- Bouton d'upload de document conservé mais rendu invisible par CSS -->
            <label for="document-upload" class="document-upload-btn" title="Ajouter un document">
                <i class="fas fa-file"></i>
            </label>
            <input type="file" id="document-upload" accept=".pdf,.doc,.docx,.txt,.csv,.xls,.xlsx,.json,.html,.xml,.md,.rtf" style="display: none;">

            <!-- Voice configuration button -->
            <button id="voice-config-btn" class="voice-config-btn" title="Configure voice synthesis" style="
                padding: 0.8rem;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                background: white;
                border: 2px solid #6c5ce7;
                color: #6c5ce7;
                transition: all 0.3s ease;
                width: 40px;
                height: 40px;
                font-size: 1rem;
                box-shadow: 0 2px 8px rgba(108, 92, 231, 0.2);
            " onmouseover="this.style.background='#6c5ce7'; this.style.color='white'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='white'; this.style.color='#6c5ce7'; this.style.transform='scale(1)'" onclick="this.style.transform='scale(0.95)'" onmouseup="this.style.transform='scale(1.05)'">
                <i class="fas fa-cog"></i>
            </button>

            <button id="send-button" class="btn primary">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
</div>

<!-- Nouveau bandeau Open Source discret -->
<div class="open-source-banner">
    <div class="os-icon">
        <i class="fab fa-github"></i>
    </div>
    <div class="os-info">
        <div class="os-title">100% Gratuit et Open Source</div>
        <div class="os-subtitle">Modifiez ce projet comme vous le souhaitez</div>
    </div>
    <a href="https://github.com/univers-artifficial-intelligence/Project-AGI-ASI-AI-google-gemini-2.0-flash" 
       target="_blank" 
       rel="noopener noreferrer"
       class="github-link">
        <i class="fab fa-github"></i>
        <span>GitHub</span>
    </a>
</div>

<!-- Fenêtre modale pour la configuration des voix -->
<div id="voice-config-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Configuration des voix de synthèse</h3>
            <button class="modal-close" id="close-voice-modal">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <div class="modal-body">
            <div class="voice-config-section">
                <div class="input-group">
                    <label for="voice-language-select">Voice language:</label>
                    <select id="voice-language-select" class="voice-language-select">
                        <option value="fr-FR">Français (France)</option>
                        <option value="en-US">Anglais (États-Unis)</option>
                        <option value="en-GB">Anglais (Royaume-Uni)</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="voice-select">Available voices:</label>
                    <select id="voice-select" class="voice-select">
                        <option value="">Loading voices...</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="voice-rate">Reading speed:</label>
                    <input type="range" id="voice-rate" min="0.5" max="2" step="0.1" value="0.9" class="voice-slider">
                    <span id="voice-rate-value">0.9</span>
                </div>

                <div class="input-group">
                    <label for="voice-pitch">Pitch:</label>
                    <input type="range" id="voice-pitch" min="0.5" max="2" step="0.1" value="1" class="voice-slider">
                    <span id="voice-pitch-value">1.0</span>
                </div>

                <div class="input-group">
                    <label for="voice-volume">Volume:</label>
                    <input type="range" id="voice-volume" min="0" max="1" step="0.1" value="1" class="voice-slider">
                    <span id="voice-volume-value">1.0</span>
                </div>

                <div class="voice-test-section">
                    <button id="test-voice-btn" class="btn-test-voice">
                        <i class="fas fa-play"></i> Test voice
                    </button>
                </div>

                <div class="voice-actions">
                    <button id="save-voice-config-btn" class="btn-save">
                        <i class="fas fa-save"></i> Save
                    </button>
                    <button id="reset-voice-config-btn" class="btn-reset">
                        <i class="fas fa-undo"></i> Reset
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Fenêtre modale pour la configuration des APIs -->
<div id="api-config-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Configuration des APIs</h3>
            <button class="modal-close" id="close-api-modal">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <div class="modal-body">
            <div class="status-message" id="api-status-message" style="display: none;"></div>

            <div class="api-list" id="modal-api-list">
                <!-- Les APIs seront chargées dynamiquement ici -->
                <div class="loading-placeholder">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading APIs...</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/chat.js') }}"></script>
<script>
    // Mise à jour de l'heure en temps réel
    function updateTime() {
        const now = new Date();
        const timeZone = document.getElementById('timezone-select').value;
        const timeString = now.toLocaleTimeString('fr-FR', { 
            hour: '2-digit', 
            minute: '2-digit',
            timeZone: timeZone
        });
        const timeElement = document.getElementById('current-time');
        if (timeElement) {
            timeElement.textContent = timeString;
        }
    }

    // Détection du fuseau horaire de l'utilisateur
    function detectUserTimeZone() {
        try {
            const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const timezoneSelect = document.getElementById('timezone-select');

            // Si le fuseau horaire détecté existe dans la liste, le sélectionner
            for (let i = 0; i < timezoneSelect.options.length; i++) {
                if (timezoneSelect.options[i].value === timezone) {
                    timezoneSelect.selectedIndex = i;
                    break;
                }
            }
        } catch (error) {
            console.error('Erreur lors de la détection du fuseau horaire:', error);
        }
    }

    // Changement de fuseau horaire
    document.getElementById('timezone-select').addEventListener('change', updateTime);

    // Mettre à jour l'heure toutes les secondes
    setInterval(updateTime, 1000);

    // Initialisation
    detectUserTimeZone();
    updateTime(); // Mise à jour immédiate

    // Configuration des voix de synthèse
    let voiceConfig = {
        language: 'fr-FR',
        voice: null,
        rate: 0.9,
        pitch: 1.0,
        volume: 1.0
    };

    // Charger la configuration des voix depuis le localStorage
    function loadVoiceConfig() {
        const saved = localStorage.getItem('voiceConfig');
        if (saved) {
            try {
                const savedConfig = JSON.parse(saved);
                voiceConfig = { ...voiceConfig, ...savedConfig };
            } catch (e) {
                console.error('Erreur lors du chargement de la configuration des voix:', e);
            }
        }
    }

    // Sauvegarder la configuration des voix dans le localStorage
    function saveVoiceConfig() {
        try {
            localStorage.setItem('voiceConfig', JSON.stringify(voiceConfig));
        } catch (e) {
            console.error('Erreur lors de la sauvegarde de la configuration des voix:', e);
        }
    }

    // Fonction de synthèse vocale améliorée avec configuration
    function speakText(text) {
        // Vérifier si la synthèse vocale est supportée
        if ('speechSynthesis' in window && typeof speechSynthesis !== 'undefined') {
            // Arrêter toute synthèse en cours
            speechSynthesis.cancel();
            
            // Créer une nouvelle instance de SpeechSynthesisUtterance
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Appliquer la configuration
            utterance.lang = voiceConfig.language;
            utterance.rate = voiceConfig.rate;
            utterance.pitch = voiceConfig.pitch;
            utterance.volume = voiceConfig.volume;
            
            // Utiliser la voix configurée si disponible
            if (voiceConfig.voice) {
                const voices = speechSynthesis.getVoices();
                const selectedVoice = voices.find(voice => voice.name === voiceConfig.voice);
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
            } else {
                // Sélection automatique de la voix selon la langue
                const voices = speechSynthesis.getVoices();
                const languageVoices = voices.filter(voice => voice.lang === voiceConfig.language);
                if (languageVoices.length > 0) {
                    utterance.voice = languageVoices[0];
                }
            }
            
            // Indicateur visuel pendant la lecture
            const voiceBtn = document.getElementById('voice-synthesis-btn');
            const originalIcon = voiceBtn.innerHTML;
            
            utterance.onstart = function() {
                voiceBtn.innerHTML = '<i class="fas fa-stop" style="color: #e74c3c;"></i>';
                voiceBtn.title = 'Arrêter la lecture';
                voiceBtn.style.borderColor = '#e74c3c';
            };
            
            utterance.onend = function() {
                voiceBtn.innerHTML = originalIcon;
                voiceBtn.title = 'Lire avec la synthèse vocale';
                voiceBtn.style.borderColor = '#6c5ce7';
            };
            
            utterance.onerror = function() {
                voiceBtn.innerHTML = originalIcon;
                voiceBtn.title = 'Lire avec la synthèse vocale';
                voiceBtn.style.borderColor = '#6c5ce7';
                console.error('Erreur lors de la synthèse vocale');
            };
            
            // Démarrer la synthèse
            speechSynthesis.speak(utterance);
        } else {
            alert('La synthèse vocale n\'est pas supportée par votre navigateur');
        }
    }

    // Gestionnaire du bouton de synthèse vocale
    document.addEventListener('DOMContentLoaded', function() {
        const voiceBtn = document.getElementById('voice-synthesis-btn');
        
        voiceBtn.addEventListener('click', function() {
            // Récupérer le dernier message de l'IA
            const messages = document.querySelectorAll('.message.bot');
            if (messages.length > 0) {
                const lastBotMessage = messages[messages.length - 1];
                const textContent = lastBotMessage.textContent.trim();
                
                if (textContent) {
                    // Si une synthèse est en cours, l'arrêter
                    if (speechSynthesis.speaking) {
                        speechSynthesis.cancel();
                        voiceBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                        voiceBtn.title = 'Lire avec la synthèse vocale';
                        voiceBtn.style.borderColor = '#6c5ce7';
                    } else {
                        // Démarrer la synthèse
                        speakText(textContent);
                    }
                } else {
                    alert('Aucun texte à lire');
                }
            } else {
                alert('Aucun message de l\'IA à lire');
            }
        });
        
        // Charger les voix disponibles (nécessaire pour certains navigateurs)
        if ('speechSynthesis' in window) {
            speechSynthesis.onvoiceschanged = function() {
                // Les voix sont maintenant chargées
                console.log('Voix disponibles:', speechSynthesis.getVoices().map(v => `${v.name} (${v.lang})`));
            };
            
            // Forcer le chargement des voix
            speechSynthesis.getVoices();
        } else {
            console.error('speechSynthesis n\'est pas supporté par ce navigateur');
        }
    });

    // Gestion de la modale de configuration des voix
    document.addEventListener('DOMContentLoaded', function() {
        const voiceConfigBtn = document.getElementById('voice-config-btn');
        const voiceConfigModal = document.getElementById('voice-config-modal');
        const closeVoiceModal = document.getElementById('close-voice-modal');
        const voiceLanguageSelect = document.getElementById('voice-language-select');
        const voiceSelect = document.getElementById('voice-select');
        const voiceRateSlider = document.getElementById('voice-rate');
        const voicePitchSlider = document.getElementById('voice-pitch');
        const voiceVolumeSlider = document.getElementById('voice-volume');
        const testVoiceBtn = document.getElementById('test-voice-btn');
        const saveVoiceConfigBtn = document.getElementById('save-voice-config-btn');
        const resetVoiceConfigBtn = document.getElementById('reset-voice-config-btn');

        // Charger la configuration des voix au démarrage
        loadVoiceConfig();

        // Ouvrir la modale de configuration des voix
        voiceConfigBtn.addEventListener('click', function() {
            voiceConfigModal.style.display = 'block';
            loadAvailableVoices();
            updateVoiceConfigUI();
        });

        // Fermer la modale de configuration des voix
        closeVoiceModal.addEventListener('click', function() {
            voiceConfigModal.style.display = 'none';
        });

        // Fermer la modale en cliquant en dehors
        window.addEventListener('click', function(event) {
            if (event.target === voiceConfigModal) {
                voiceConfigModal.style.display = 'none';
            }
        });

        // Charger les voix disponibles
        function loadAvailableVoices() {
            const voices = speechSynthesis.getVoices();
            const selectedLanguage = voiceLanguageSelect.value;
            const filteredVoices = voices.filter(voice => voice.lang === selectedLanguage);

            voiceSelect.innerHTML = '';
            
            if (filteredVoices.length === 0) {
                voiceSelect.innerHTML = '<option value="">Aucune voix disponible</option>';
                return;
            }

            filteredVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} ${voice.localService ? '(Local)' : '(En ligne)'}`;
                voiceSelect.appendChild(option);
            });

            // Sélectionner la voix configurée si elle existe
            if (voiceConfig.voice) {
                voiceSelect.value = voiceConfig.voice;
            }
        }

        // Mettre à jour l'interface utilisateur avec la configuration actuelle
        function updateVoiceConfigUI() {
            voiceLanguageSelect.value = voiceConfig.language;
            voiceRateSlider.value = voiceConfig.rate;
            voicePitchSlider.value = voiceConfig.pitch;
            voiceVolumeSlider.value = voiceConfig.volume;
            
            document.getElementById('voice-rate-value').textContent = voiceConfig.rate;
            document.getElementById('voice-pitch-value').textContent = voiceConfig.pitch;
            document.getElementById('voice-volume-value').textContent = voiceConfig.volume;
        }

        // Gestionnaire de changement de langue
        voiceLanguageSelect.addEventListener('change', function() {
            voiceConfig.language = this.value;
            loadAvailableVoices();
        });

        // Gestionnaire de changement de voix
        voiceSelect.addEventListener('change', function() {
            voiceConfig.voice = this.value;
        });

        // Gestionnaires des sliders
        voiceRateSlider.addEventListener('input', function() {
            voiceConfig.rate = parseFloat(this.value);
            document.getElementById('voice-rate-value').textContent = this.value;
        });

        voicePitchSlider.addEventListener('input', function() {
            voiceConfig.pitch = parseFloat(this.value);
            document.getElementById('voice-pitch-value').textContent = this.value;
        });

        voiceVolumeSlider.addEventListener('input', function() {
            voiceConfig.volume = parseFloat(this.value);
            document.getElementById('voice-volume-value').textContent = this.value;
        });

        // Tester la voix
        testVoiceBtn.addEventListener('click', function() {
            const testText = "Ceci est un test de la synthèse vocale. Hello, this is a voice synthesis test.";
            speakText(testText);
        });

        // Sauvegarder la configuration
        saveVoiceConfigBtn.addEventListener('click', function() {
            saveVoiceConfig();
            alert('Configuration des voix sauvegardée !');
        });

        // Réinitialiser la configuration
        resetVoiceConfigBtn.addEventListener('click', function() {
            voiceConfig = {
                language: 'fr-FR',
                voice: null,
                rate: 0.9,
                pitch: 1.0,
                volume: 1.0
            };
            updateVoiceConfigUI();
            loadAvailableVoices();
            saveVoiceConfig();
            alert('Configuration des voix réinitialisée !');
        });

        // Charger les voix lors du changement de voix disponibles
        if ('speechSynthesis' in window) {
            speechSynthesis.onvoiceschanged = function() {
                if (voiceConfigModal.style.display === 'block') {
                    loadAvailableVoices();
                }
            };
        }
    });

    // Gestion de la modale API Config
    document.addEventListener('DOMContentLoaded', function() {
        const mobileConfigBtn = document.getElementById('mobile-config-btn');
        const apiConfigModal = document.getElementById('api-config-modal');
        const closeApiModal = document.getElementById('close-api-modal');

        // Fonction pour ouvrir la modale
        function openApiConfigModal() {
            apiConfigModal.style.display = 'block';
            loadModalApisOptimized(); // Utiliser la version optimisée avec cache

            // If modal doesn't load after 8 seconds, show error message
            setTimeout(() => {
                const apiList = document.getElementById('modal-api-list');
                const loadingPlaceholder = apiList.querySelector('.loading-placeholder');
                if (loadingPlaceholder) {
                    apiList.innerHTML = '<div class="error-message">Loading took too long. <button onclick="loadModalApisOptimized()" class="retry-btn">Retry</button></div>';
                }
            }, 8000);
        }

        // Open modal from mobile navigation button
        if (mobileConfigBtn) {
            mobileConfigBtn.addEventListener('click', function(e) {
                e.preventDefault();
                openApiConfigModal();
            });
        }

        // Fermer la modale
        closeApiModal.addEventListener('click', function() {
            apiConfigModal.style.display = 'none';
        });

        // Fermer la modale en cliquant en dehors
        window.addEventListener('click', function(event) {
            if (event.target === apiConfigModal) {
                apiConfigModal.style.display = 'none';
            }
        });

        // Fonction pour charger les APIs dans la modale
        function loadModalApis() {
            const apiList = document.getElementById('modal-api-list');

            // Afficher le message de chargement avec indicateur de progression
            apiList.innerHTML = `<div class="loading-placeholder">
                <i class="fas fa-spinner fa-spin"></i>
                <p>Chargement des APIs...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="loading-progress"></div>
                </div>
            </div>`;

            // Variables pour le suivi du progès
            let loadingSteps = 0;
            const totalSteps = 3; // APIs list, API keys, API configurations

            // Fonction pour mettre à jour la barre de progression
            const updateProgress = () => {
                loadingSteps++;
                const progress = (loadingSteps / totalSteps) * 100;
                const progressBar = document.getElementById('loading-progress');
                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                }
            };

            // Délai maximum réduit pour les requêtes fetch
            const timeoutDuration = 5000; // Réduit de 10s à 5s

            // Fonction pour créer une promesse avec timeout optimisé
            const fetchWithTimeout = (url, options = {}) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);

                return fetch(url, { 
                    ...options, 
                    signal: controller.signal,
                    cache: 'no-cache', // Éviter les problèmes de cache
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                })
                .then(response => {
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP ${response.status} pour ${url}`);
                    }
                    updateProgress();
                    return response.json();
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error(`Délai dépassé pour ${url}`);
                    }
                    throw error;
                });
            };

            // Chargement des données de base avec promesses optimisées
            const loadBaseData = Promise.all([
                fetchWithTimeout('/api/config/apis').catch(err => {
                    console.warn('Erreur lors du chargement des configurations API:', err);
                    updateProgress(); // Mettre à jour même en cas d'erreur
                    return { available_apis: [], current_api: null, error: true };
                }),
                fetchWithTimeout('/api/keys').catch(err => {
                    console.warn('Erreur lors du chargement des clés API:', err);
                    updateProgress(); // Mettre à jour même en cas d'erreur
                    return { api_keys: {}, error: true };
                })
            ]);

            loadBaseData
            .then(([apisData, keysData]) => {
                // Check if both requests failed
                if (apisData.error && keysData.error) {
                    apiList.innerHTML = '<div class="error-message">Error loading APIs. <button onclick="loadModalApis()" class="retry-btn">Retry</button></div>';
                    return;
                }

                // Utiliser les données disponibles
                const availableApis = apisData.available_apis || [];
                const currentApi = apisData.current_api || null;
                const apiKeys = keysData.api_keys || {};

                // Rendu immédiat des cartes d'API de base (sans configs détaillées)
                renderModalApiCardsBasic(availableApis, currentApi, apiKeys);

                // Charger les configurations détaillées en arrière-plan
                if (availableApis.length > 0) {
                    preloadApiConfigurations(availableApis)
                        .then(apiConfigs => {
                            updateProgress(); // Dernière étape
                            // Mettre à jour les cartes avec les configurations complètes
                            renderModalApiCards(availableApis, currentApi, apiKeys, apiConfigs);
                            // Mettre en cache les données pour les prochaines utilisations
                            updateCache(availableApis, currentApi, apiKeys, apiConfigs);
                        })
                        .catch(error => {
                            console.warn('Erreur lors du chargement des configs détaillées:', error);
                            updateProgress();
                            // Les cartes de base restent fonctionnelles même sans configs détaillées
                            // Mettre en cache les données de base même sans configs détaillées
                            updateCache(availableApis, currentApi, apiKeys, {});
                        });
                } else {
                    updateProgress();
                    // Mettre en cache même s'il n'y a pas d'APIs disponibles
                    updateCache(availableApis, currentApi, apiKeys, {});
                }
            })
            .catch(error => {
                console.error('Erreur lors du chargement des APIs:', error);
                apiList.innerHTML = '<div class="error-message">Erreur de connexion. <button onclick="loadModalApis()" class="retry-btn">Réessayer</button></div>';
            });
        }

        // Cache simple pour éviter les rechargements inutiles
        let apiDataCache = null;
        let cacheTimestamp = 0;
        const CACHE_DURATION = 30000; // 30 secondes

        // Fonction pour vérifier si le cache est valide
        function isCacheValid() {
            return apiDataCache && (Date.now() - cacheTimestamp) < CACHE_DURATION;
        }

        // Fonction pour charger depuis le cache ou depuis l'API
        function loadModalApisOptimized() {
            const apiList = document.getElementById('modal-api-list');

            // Si le cache est valide, utiliser les données en cache
            if (isCacheValid()) {
                console.log('Utilisation du cache API');
                apiList.innerHTML = `<div class="loading-placeholder">
                    <i class="fas fa-check-circle" style="color: #18cc87;"></i>
                    <p>Chargement depuis le cache...</p>
                </div>`;

                setTimeout(() => {
                    renderModalApiCards(
                        apiDataCache.availableApis, 
                        apiDataCache.currentApi, 
                        apiDataCache.apiKeys, 
                        apiDataCache.apiConfigs
                    );
                }, 100);
                return;
            }

            // Sinon, charger normalement et mettre en cache
            loadModalApis();
        }

        // Fonction pour mettre à jour le cache
        function updateCache(availableApis, currentApi, apiKeys, apiConfigs) {
            apiDataCache = {
                availableApis,
                currentApi,
                apiKeys,
                apiConfigs: apiConfigs || {}
            };
            cacheTimestamp = Date.now();
        }

        // Fonction pour invalider le cache (à appeler après des modifications)
        function invalidateCache() {
            apiDataCache = null;
            cacheTimestamp = 0;
        }

        // Nouvelle fonction pour un rendu rapide des cartes de base
        function renderModalApiCardsBasic(apis, currentApi, apiKeys) {
            const apiList = document.getElementById('modal-api-list');

            // Effacer l'indicateur de chargement
            apiList.innerHTML = '';

            // Afficher les cartes d'API avec informations de base
            apis.forEach(apiName => {
                const isActive = apiName === currentApi;
                const apiKey = apiKeys[apiName] || '';
                const hasKey = apiKey && apiKey.length > 0;

                const card = document.createElement('div');
                card.className = `modal-api-card ${isActive ? 'active' : ''}`;
                card.id = `api-card-${apiName}`;

                let cardHTML = `
                    <div class="api-header">
                        <div class="api-info">
                            <span class="api-name">${getApiDisplayName(apiName)}</span>
                            <span class="api-status ${isActive ? 'active' : ''}">${isActive ? 'Active' : 'Inactive'}</span>
                        </div>
                        ${hasKey ? '<i class="fas fa-check-circle api-key-status has-key" title="API key configured"></i>' : '<i class="fas fa-exclamation-circle api-key-status no-key" title="API key missing"></i>'}
                    </div>

                    <div class="api-config">
                        <div class="input-group">
                            <label for="modal-${apiName}-key">API Key:</label>
                            <div class="input-wrapper">
                                <input 
                                    type="password" 
                                    id="modal-${apiName}-key" 
                                    placeholder="Enter your ${getApiDisplayName(apiName)} API key"
                                    value="${apiKey}"
                                />
                                <button class="toggle-password" type="button" onclick="togglePasswordVisibility('modal-${apiName}-key')">
                                    <i class="fas fa-eye"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                card.innerHTML = cardHTML;
                apiList.appendChild(card);
            });
        }

        // Fonction optimisée pour précharger toutes les configurations d'API
        async function preloadApiConfigurations(apis) {
            const configs = {};
            const configTimeout = 3000; // Timeout réduit à 3 secondes pour les configs

            // Téléchargement parallèle avec timeout optimisé et limite de retry
            const promises = apis.map(async (apiName) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), configTimeout);

                try {
                    const response = await fetch(`/api/config/apis/${apiName}`, {
                        signal: controller.signal,
                        cache: 'no-cache',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });

                    clearTimeout(timeoutId);

                    if (response.ok) {
                        const data = await response.json();
                        configs[apiName] = data.config || {};
                    } else {
                        console.warn(`HTTP ${response.status} pour la config ${apiName}`);
                        configs[apiName] = {};
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        console.warn(`Timeout lors du chargement de la config pour ${apiName}`);
                    } else {
                        console.warn(`Erreur lors du chargement de la config pour ${apiName}:`, error.message);
                    }
                    configs[apiName] = {};
                }
            });

            // Attendre toutes les promesses (même celles qui échouent)
            await Promise.allSettled(promises);
            return configs;
        }

        // Fonction optimisée pour afficher les cartes d'API complètes dans la modale
        function renderModalApiCards(apis, currentApi, apiKeys, apiConfigs = {}) {
            const apiList = document.getElementById('modal-api-list');

            try {
                // Vérifier si les APIs sont valides
                if (!Array.isArray(apis) || apis.length === 0) {
                    apiList.innerHTML = '<div class="error-message">Aucune API disponible</div>';
                    return;
                }

                // Effacer le contenu existant
                apiList.innerHTML = '';

                // Utiliser un fragment pour optimiser les performances DOM
                const fragment = document.createDocumentFragment();

                // Afficher les cartes d'API
                apis.forEach(apiName => {
                    const isActive = apiName === currentApi;
                    const apiKey = apiKeys[apiName] || '';
                    const hasKey = apiKey && apiKey.length > 0;
                    const isCustomLLM = apiName === 'custom_llm';
                    const apiConfig = apiConfigs[apiName] || {};

                    const card = document.createElement('div');
                    card.className = `modal-api-card ${isActive ? 'active' : ''}`;
                    card.id = `api-card-${apiName}`;

                    let cardHTML = `
                        <div class="api-header">
                            <div class="api-info">
                                <span class="api-name">${getApiDisplayName(apiName)}</span>
                                <span class="api-status ${isActive ? 'active' : ''}">${isActive ? 'Active' : 'Inactive'}</span>
                            </div>
                            ${hasKey ? '<i class="fas fa-check-circle api-key-status has-key" title="API key configured"></i>' : '<i class="fas fa-exclamation-circle api-key-status no-key" title="API key missing"></i>'}
                        </div>

                        <div class="api-config">
                            <div class="input-group">
                                <label for="modal-${apiName}-key">API Key:</label>
                                <div class="input-wrapper">
                                    <input 
                                        type="password" 
                                        id="modal-${apiName}-key" 
                                        placeholder="Entrez votre clé API ${getApiDisplayName(apiName)}"
                                        value="${apiKey}"
                                    />
                                    <button class="toggle-password" type="button" onclick="togglePasswordVisibility('modal-${apiName}-key')">
                                        <i class="fas fa-eye"></i>
                                    </button>
                                </div>
                            </div>`;

                    // Add API URL field only for custom LLM
                    if (isCustomLLM) {
                        const apiUrl = apiConfig.api_url || '';
                        cardHTML += `
                            <div class="input-group">
                                <label for="modal-${apiName}-url">API URL:</label>
                                <div class="input-wrapper">
                                    <input 
                                        type="text" 
                                        id="modal-${apiName}-url" 
                                        placeholder="Enter your custom LLM API URL"
                                        value="${apiUrl}"
                                    />
                                </div>
                            </div>`;
                    }

                    // Add action buttons
                    cardHTML += `
                            <div class="api-actions">
                                <button class="btn-save" onclick="saveModalApiKey('${apiName}')">
                                    <i class="fas fa-save"></i> Save
                                </button>
                                ${hasKey ? `<button class="btn-delete" onclick="deleteModalApiKey('${apiName}')">
                                    <i class="fas fa-trash"></i> Delete
                                </button>` : ''}
                                ${!isActive && hasKey ? `<button class="btn-activate" onclick="activateModalApi('${apiName}')">
                                    <i class="fas fa-play"></i> Activate
                                </button>` : ''}
                            </div>
                        </div>
                    `;

                    card.innerHTML = cardHTML;
                    fragment.appendChild(card);
                });

                // Ajouter toutes les cartes en une seule fois
                apiList.appendChild(fragment);

            } catch (error) {
                console.error('Erreur lors du rendu des cartes API:', error);
                apiList.innerHTML = '<div class="error-message">Erreur lors de l\'affichage des APIs</div>';
            }
        }

        // Fonctions utilitaires pour la modale API
        window.getApiDisplayName = function(apiName) {
            const names = {
                'gemini': 'Google Gemini 2.0 Flash',
                'claude': 'Claude by Anthropic',
                'gpt4': 'OpenAI GPT-4',
                'llama': 'Meta LLaMA',
                'custom_llm': 'LLM Personnalisé'
            };
            return names[apiName] || apiName.charAt(0).toUpperCase() + apiName.slice(1);
        };

        window.togglePasswordVisibility = function(inputId) {
            const input = document.getElementById(inputId);
            const icon = input.nextElementSibling.querySelector('i');

            if (input.type === 'password') {
                input.type = 'text';
                icon.className = 'fas fa-eye-slash';
            } else {
                input.type = 'password';
                icon.className = 'fas fa-eye';
            }
        };

        window.saveModalApiKey = function(apiName) {
            const input = document.getElementById(`modal-${apiName}-key`);
            const apiKey = input.value.trim();
            const isCustomLLM = apiName === 'custom_llm';

            if (!apiKey) {
                showModalMessage('API key cannot be empty', 'error');
                return;
            }

            // Afficher un message de chargement
            showModalMessage('Saving in progress...', 'info');

            // Sauvegarder la clé API
            const saveKey = fetch(`/api/keys/${apiName}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ api_key: apiKey })
            }).then(response => response.json());

            // Si c'est le LLM personnalisé, on sauvegarde aussi l'URL
            let saveUrl = Promise.resolve({ success: true });
            if (isCustomLLM) {
                const urlInput = document.getElementById(`modal-${apiName}-url`);
                const apiUrl = urlInput.value.trim();

                if (!apiUrl) {
                    showModalMessage('API URL cannot be empty for custom LLM', 'error');
                    return;
                }

                saveUrl = fetch(`/api/config/apis/${apiName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: {
                            api_url: apiUrl
                        }
                    })
                }).then(response => response.json());
            }

            // Attendre que les deux requêtes soient terminées
            Promise.all([saveKey, saveUrl])
            .then(([keyData, urlData]) => {
                if (keyData.success && (!isCustomLLM || urlData.success)) {
                    showModalMessage(`${getApiDisplayName(apiName)} configuration saved`, 'success');
                    // Invalider le cache et recharger avec la version optimisée
                    invalidateCache();
                    loadModalApisOptimized();
                } else {
                    showModalMessage(keyData.error || urlData.error || 'Error during save', 'error');
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                showModalMessage('Erreur de connexion', 'error');
            });
        };

        window.deleteModalApiKey = function(apiName) {
            if (!confirm(`Êtes-vous sûr de vouloir supprimer la clé API ${getApiDisplayName(apiName)} ?`)) {
                return;
            }

            // Afficher un message de chargement            showModalMessage('Suppression en cours...', 'info');

            fetch(`/api/keys/${apiName}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showModalMessage(`Clé API ${getApiDisplayName(apiName)} supprimée`, 'success');
                    // Invalider le cache et recharger avec la version optimisée
                    invalidateCache();
                    loadModalApisOptimized();
                } else {
                    showModalMessage(data.error || 'Erreur lors de la suppression', 'error');
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                showModalMessage('Erreur de connexion', 'error');
            });
        };

        window.activateModalApi = function(apiName) {
            // Pour le LLM personnalisé, vérifier que l'URL est configurée
            if (apiName === 'custom_llm') {
                // Afficher un message de chargement
                showModalMessage('Vérification de la configuration...', 'info');

                // Ajouter un délai d'expiration pour la requête
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Délai dépassé')), 5000);
                });

                Promise.race([
                    fetch(`/api/config/apis/${apiName}`),
                    timeoutPromise
                ])
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data.config || !data.config.api_url) {
                        showModalMessage('Please configure the API URL for the custom LLM before activating it', 'error');
                        return;
                    } else {
                        // URL is configured, we can activate the API
                        activateApi(apiName);
                    }
                })
                .catch(error => {
                    console.error('Erreur lors de la vérification de la configuration:', error);
                    showModalMessage('Erreur lors de la vérification de la configuration, activation annulée', 'error');
                });
            } else {
                // Pour les autres APIs, on active directement
                activateApi(apiName);
            }
        };

        function activateApi(apiName) {
            // Afficher un message de chargement
            showModalMessage('Activation en cours...', 'info');

            fetch('/api/config/apis/current', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ api_name: apiName })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showModalMessage(`API ${getApiDisplayName(apiName)} activée`, 'success');
                    // Invalider le cache et recharger avec la version optimisée
                    invalidateCache();
                    loadModalApisOptimized();
                } else {
                    showModalMessage(data.error || 'Erreur lors de l\'activation', 'error');
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                showModalMessage('Erreur de connexion', 'error');
            });
        };

        // Variable pour stocker le timeout ID
        let messageTimeout;

        function showModalMessage(message, type) {
            const messageEl = document.getElementById('api-status-message');

            // Si un message est déjà affiché, annuler son timeout
            if (messageTimeout) {
                clearTimeout(messageTimeout);
            }

            // Mettre à jour le message
            messageEl.textContent = message;
            messageEl.className = `status-message ${type || 'info'}`;
            messageEl.style.display = 'block';

            // Types d'erreurs affichés plus longtemps
            const duration = type === 'error' ? 5000 : 3000;

            // Définir le nouveau timeout
            messageTimeout = setTimeout(() => {
                // Effet de fondu avant de masquer
                messageEl.style.opacity = '0';
                setTimeout(() => {
                    messageEl.style.display = 'none';
                    messageEl.style.opacity = '1';
                }, 300);
            }, duration);
        }
    });
</script>
{% endblock %}