#!/usr/bin/env python3
"""
Installateur adaptatif pour Termux et autres plateformes
G√®re l'installation intelligente des d√©pendances selon l'environnement
"""

import subprocess
import sys
import logging
import os
from typing import List, Dict, Tuple, Optional
from platform_detector import get_platform_detector

logger = logging.getLogger('TermuxInstaller')

class TermuxInstaller:
    """Installateur intelligent pour Termux et Android"""
    
    def __init__(self):
        self.detector = get_platform_detector()
        self.platform_info = self.detector.platform_info
        self.config = self.detector.config
        
        # Modules adapt√©s pour Termux
        self.termux_compatible_modules = {
            # Modules de base - toujours compatibles
            'requests': 'requests>=2.31.0',
            'flask': 'flask>=2.3.0',
            'flask_compress': 'flask-compress>=1.14',
            'numpy': 'numpy>=1.24.0',
            'pandas': 'pandas>=2.0.0',
            'pillow': 'pillow>=10.0.0',
            'beautifulsoup4': 'beautifulsoup4>=4.12.0',
            'lxml': 'lxml>=4.9.0',
            
            # Modules avec alternatives pour Termux
            'aiohttp': 'aiohttp>=3.8.0',
            'networkx': 'networkx>=3.0',
            'matplotlib': 'matplotlib>=3.7.0',  # Peut n√©cessiter des packages syst√®me
            'scipy': 'scipy>=1.10.0',  # Compilation longue sur Termux
            
            # Modules probl√©matiques sur Termux (alternatives)
            'opencv-python': None,  # Utiliser opencv-python-headless
            'librosa': None,  # Audio limit√© sur Android
            'soundfile': None,  # Audio limit√© sur Android
            'selenium': None,  # Pas de navigateur complet sur Termux
            'pytesseract': None,  # Tesseract complexe √† installer
        }
        
        # Alternatives pour les modules probl√©matiques
        self.termux_alternatives = {
            'cv2': 'opencv-python-headless>=4.8.0',
            'selenium': 'requests-html>=0.10.0',  # Alternative l√©g√®re
            'librosa': 'scipy>=1.10.0',  # Pour certaines fonctions audio basiques
            'pytesseract': 'easyocr>=1.7.0',  # OCR alternatif
        }
        
        # Packages syst√®me requis pour Termux
        self.termux_system_packages = [
            'python',
            'python-pip',
            'git',
            'curl',
            'wget',
            'clang',
            'pkg-config',
            'libjpeg-turbo',
            'libpng',
            'zlib',
            'openssl'
        ]
    
    def setup_termux_environment(self) -> bool:
        """Configure l'environnement Termux initial"""
        if not self.platform_info['is_termux']:
            logger.info("Non-Termux environment detected, skipping Termux setup")
            return True
        
        logger.info("ü§ñ Configuration de l'environnement Termux...")
        
        # 1. Mettre √† jour les packages
        if not self._update_termux_packages():
            return False
        
        # 2. Installer les packages syst√®me requis
        if not self._install_termux_system_packages():
            return False
        
        # 3. Configurer pip
        if not self._configure_pip_for_termux():
            return False
        
        # 4. Cr√©er les r√©pertoires de donn√©es
        self._create_data_directories()
        
        logger.info("‚úÖ Environnement Termux configur√© avec succ√®s")
        return True
    
    def _update_termux_packages(self) -> bool:
        """Met √† jour les packages Termux"""
        try:
            logger.info("üì¶ Mise √† jour des packages Termux...")
            result = subprocess.run(['pkg', 'update', '-y'], 
                                  capture_output=True, text=True, timeout=300)
            if result.returncode != 0:
                logger.warning(f"Avertissement lors de la mise √† jour: {result.stderr}")
            return True
        except Exception as e:
            logger.error(f"Erreur lors de la mise √† jour: {e}")
            return False
    
    def _install_termux_system_packages(self) -> bool:
        """Installe les packages syst√®me Termux requis"""
        try:
            logger.info("üîß Installation des packages syst√®me...")
            for package in self.termux_system_packages:
                logger.info(f"Installation de {package}...")
                result = subprocess.run(['pkg', 'install', '-y', package], 
                                      capture_output=True, text=True, timeout=300)
                if result.returncode != 0:
                    logger.warning(f"Package {package} d√©j√† install√© ou erreur: {result.stderr}")
            return True
        except Exception as e:
            logger.error(f"Erreur lors de l'installation des packages syst√®me: {e}")
            return False
    
    def _configure_pip_for_termux(self) -> bool:
        """Configure pip pour Termux"""
        try:
            logger.info("üêç Configuration de pip pour Termux...")
            
            # Mettre √† jour pip
            subprocess.run([sys.executable, '-m', 'pip', 'install', '--upgrade', 'pip'], 
                          capture_output=True, text=True)
            
            # Installer wheel pour √©viter les compilations
            subprocess.run([sys.executable, '-m', 'pip', 'install', 'wheel'], 
                          capture_output=True, text=True)
            
            return True
        except Exception as e:
            logger.error(f"Erreur lors de la configuration de pip: {e}")
            return False
    
    def _create_data_directories(self):
        """Cr√©e les r√©pertoires de donn√©es n√©cessaires"""
        data_path = self.detector.get_data_path()
        directories = [
            data_path,
            os.path.join(data_path, 'conversations'),
            os.path.join(data_path, 'uploads'),
            os.path.join(data_path, 'cache'),
            os.path.join(data_path, 'logs')
        ]
        
        for directory in directories:
            os.makedirs(directory, exist_ok=True)
            logger.info(f"üìÅ R√©pertoire cr√©√©: {directory}")
    
    def install_python_dependencies(self, modules: List[str]) -> Tuple[List[str], List[str]]:
        """Installe les d√©pendances Python adapt√©es √† la plateforme"""
        successful = []
        failed = []
        
        for module in modules:
            if self._install_single_module(module):
                successful.append(module)
            else:
                failed.append(module)
                # Essayer une alternative si disponible
                alternative = self._get_module_alternative(module)
                if alternative and self._install_single_module(alternative):
                    successful.append(f"{module} (via {alternative})")
                    failed.remove(module)
        
        return successful, failed
    
    def _install_single_module(self, module: str) -> bool:
        """Installe un module Python unique"""
        try:
            # D√©terminer le nom du package √† installer
            if module in self.termux_compatible_modules:
                package_spec = self.termux_compatible_modules[module]
                if package_spec is None:
                    logger.info(f"‚ö†Ô∏è  Module {module} non compatible avec Termux")
                    return False
            else:
                package_spec = module
            
            logger.info(f"üì¶ Installation de {package_spec}...")
            
            # Options sp√©ciales pour Termux
            pip_args = [sys.executable, '-m', 'pip', 'install']
            
            if self.platform_info['is_termux']:
                pip_args.extend(['--no-cache-dir', '--timeout', '300'])
            
            pip_args.append(package_spec)
            
            result = subprocess.run(pip_args, capture_output=True, text=True, timeout=600)
            
            if result.returncode == 0:
                logger.info(f"‚úÖ {module} install√© avec succ√®s")
                return True
            else:
                logger.warning(f"‚ùå √âchec de l'installation de {module}: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            logger.error(f"‚è∞ Timeout lors de l'installation de {module}")
            return False
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'installation de {module}: {e}")
            return False
    
    def _get_module_alternative(self, module: str) -> Optional[str]:
        """Retourne une alternative pour un module si disponible"""
        return self.termux_alternatives.get(module)
    
    def generate_termux_requirements(self, base_requirements: List[str]) -> str:
        """G√©n√®re un fichier requirements.txt adapt√© √† Termux"""
        termux_requirements = []
        
        for req in base_requirements:
            module_name = req.split('>=')[0].split('==')[0].strip()
            
            if module_name in self.termux_compatible_modules:
                package_spec = self.termux_compatible_modules[module_name]
                if package_spec:
                    termux_requirements.append(package_spec)
            elif module_name in self.termux_alternatives:
                termux_requirements.append(self.termux_alternatives[module_name])
            else:
                termux_requirements.append(req)
        
        return '\n'.join(termux_requirements)
    
    def create_termux_launcher(self, app_file: str = 'app.py') -> str:
        """Cr√©e un script de lancement adapt√© √† Termux"""
        launcher_content = f"""#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-
'''
Lanceur Termux pour l'application AI
Optimis√© pour l'environnement Android/Termux
'''

import os
import sys
import logging
from platform_detector import get_platform_detector

# Configuration des logs pour Termux
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)

logger = logging.getLogger('TermuxLauncher')

def main():
    detector = get_platform_detector()
    
    print(detector.get_platform_summary())
    
    if detector.platform_info['is_termux']:
        logger.info("ü§ñ Lancement en mode Termux...")
        
        # Configuration sp√©cifique √† Termux
        os.environ['PYTHONUNBUFFERED'] = '1'
        os.environ['FLASK_ENV'] = 'production'
        
        # Limiter l'utilisation m√©moire
        if 'MALLOC_ARENA_MAX' not in os.environ:
            os.environ['MALLOC_ARENA_MAX'] = '2'
    
    # Lancer l'application principale
    try:
        import {app_file.replace('.py', '')}
        logger.info("‚úÖ Application lanc√©e avec succ√®s")
    except ImportError as e:
        logger.error(f"‚ùå Erreur d'import: {{e}}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"‚ùå Erreur lors du lancement: {{e}}")
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
        
        return launcher_content
    
    def get_installation_summary(self) -> str:
        """Retourne un r√©sum√© de l'installation pour Termux"""
        if not self.platform_info['is_termux']:
            return "‚ùå Pas un environnement Termux"
        
        summary = """
ü§ñ GUIDE D'INSTALLATION TERMUX
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üì± 1. PR√âPARATION TERMUX:
   pkg update && pkg upgrade
   pkg install python python-pip git

üì¶ 2. PACKAGES SYST√àME REQUIS:
   """ + ' '.join(self.termux_system_packages) + """

üêç 3. MODULES PYTHON COMPATIBLES:
   ‚úÖ Modules support√©s: """ + str(len([m for m in self.termux_compatible_modules.values() if m])) + """
   ‚ö†Ô∏è  Modules avec alternatives: """ + str(len(self.termux_alternatives)) + """
   ‚ùå Modules non compatibles: """ + str(len([m for m in self.termux_compatible_modules.values() if not m])) + """

üí° 4. OPTIMISATIONS TERMUX:
   ‚Ä¢ Utilisation de --no-cache-dir pour pip
   ‚Ä¢ Timeout √©tendu pour les installations
   ‚Ä¢ Limitation de l'utilisation m√©moire
   ‚Ä¢ Chemins adapt√©s √† l'architecture Android

üöÄ 5. LANCEMENT:
   python termux_launcher.py
"""
        
        return summary

def setup_termux_compatibility():
    """Point d'entr√©e principal pour configurer la compatibilit√© Termux"""
    installer = TermuxInstaller()
    
    if installer.platform_info['is_termux']:
        print("ü§ñ Environnement Termux d√©tect√©!")
        print(installer.get_installation_summary())
        
        # Configuration automatique
        if installer.setup_termux_environment():
            print("‚úÖ Configuration Termux termin√©e avec succ√®s")
            return True
        else:
            print("‚ùå Erreur lors de la configuration Termux")
            return False
    else:
        print("‚ÑπÔ∏è  Environnement non-Termux d√©tect√©, aucune configuration sp√©ciale requise")
        return True

if __name__ == "__main__":
    setup_termux_compatibility()
