"""
Test Complet du Syst√®me de Navigation Web Avanc√© avec l'API Gemini
Ce script teste l'int√©gration compl√®te et v√©rifie que tout fonctionne
"""

import logging
import json
import time
import os
import sys
from datetime import datetime
from pathlib import Path

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('GeminiWebNavigationTest')

class GeminiWebNavigationTester:
    """Testeur complet pour le syst√®me de navigation web avec Gemini"""
    
    def __init__(self):
        self.test_results = {}
        self.errors = []
        self.passed_tests = 0
        self.total_tests = 0
        
        # Cr√©er le r√©pertoire de tests
        self.test_dir = Path("test_results")
        self.test_dir.mkdir(exist_ok=True)
        
        logger.info("üß™ Testeur Gemini-Navigation initialis√©")
    
    def log_test_result(self, test_name: str, success: bool, message: str = "", data: dict = None):
        """Enregistre le r√©sultat d'un test"""
        self.total_tests += 1
        if success:
            self.passed_tests += 1
            logger.info(f"‚úÖ {test_name}: {message}")
        else:
            logger.error(f"‚ùå {test_name}: {message}")
            self.errors.append(f"{test_name}: {message}")
        
        self.test_results[test_name] = {
            'success': success,
            'message': message,
            'data': data,
            'timestamp': datetime.now().isoformat()
        }
    
    def test_module_imports(self):
        """Test 1: V√©rifier que tous les modules s'importent correctement"""
        logger.info("üîß Test 1: Import des modules")
        
        modules_to_test = [
            ('advanced_web_navigator', 'Navigateur Web Avanc√©'),
            ('gemini_web_integration', 'Int√©gration Gemini-Web'),
            ('gemini_navigation_adapter', 'Adaptateur Navigation Gemini'),
            ('web_navigation_api', 'API REST Navigation Web'),
            ('gemini_api_adapter', 'Adaptateur Gemini Original')
        ]
        
        imported_modules = {}
        all_success = True
        
        for module_name, display_name in modules_to_test:
            try:
                module = __import__(module_name)
                imported_modules[module_name] = module
                self.log_test_result(f"Import {display_name}", True, "Module import√© avec succ√®s")
            except ImportError as e:
                self.log_test_result(f"Import {display_name}", False, f"Erreur d'import: {str(e)}")
                all_success = False
            except Exception as e:
                self.log_test_result(f"Import {display_name}", False, f"Erreur: {str(e)}")
                all_success = False
        
        self.log_test_result("Import Global", all_success, 
                           f"{len(imported_modules)}/{len(modules_to_test)} modules import√©s")
        
        return imported_modules
    
    def test_gemini_api_initialization(self):
        """Test 2: Initialiser l'API Gemini et v√©rifier l'int√©gration"""
        logger.info("ü§ñ Test 2: Initialisation API Gemini")
        
        try:
            from gemini_api_adapter import GeminiAPI
            from gemini_navigation_adapter import initialize_gemini_navigation_adapter
            
            # Cr√©er une instance Gemini
            gemini_api = GeminiAPI()
            self.log_test_result("Cr√©ation Instance Gemini", True, "API Gemini cr√©√©e")
            
            # Initialiser l'adaptateur de navigation
            initialize_gemini_navigation_adapter(gemini_api)
            self.log_test_result("Initialisation Adaptateur Navigation", True, "Adaptateur initialis√©")
            
            # V√©rifier que l'int√©gration est disponible
            from gemini_navigation_adapter import gemini_navigation_adapter
            if gemini_navigation_adapter:
                self.log_test_result("V√©rification Int√©gration", True, "Int√©gration active")
                return gemini_api
            else:
                self.log_test_result("V√©rification Int√©gration", False, "Adaptateur non initialis√©")
                return None
                
        except Exception as e:
            self.log_test_result("Initialisation API Gemini", False, f"Erreur: {str(e)}")
            return None
    
    def test_navigation_detection(self, gemini_api):
        """Test 3: Tester la d√©tection de navigation"""
        logger.info("üîç Test 3: D√©tection de Navigation")
        
        if not gemini_api:
            self.log_test_result("Test D√©tection", False, "API Gemini non disponible")
            return
        
        try:
            from gemini_navigation_adapter import detect_navigation_need
            
            # Tests de d√©tection avec diff√©rents prompts
            test_cases = [
                {
                    'prompt': "Recherche et navigue sur l'intelligence artificielle",
                    'expected_navigation': True,
                    'expected_type': 'search_and_navigate'
                },
                {
                    'prompt': "Extrait le contenu de https://example.com",
                    'expected_navigation': True,
                    'expected_type': 'content_extraction'
                },
                {
                    'prompt': "Explore le site https://wikipedia.org en profondeur",
                    'expected_navigation': True,
                    'expected_type': 'deep_navigation'
                },
                {
                    'prompt': "Simule un parcours d'achat sur ce site",
                    'expected_navigation': True,
                    'expected_type': 'user_journey'
                },
                {
                    'prompt': "Qu'est-ce que l'apprentissage automatique ?",
                    'expected_navigation': True,  # Devrait √™tre d√©tect√© comme recherche g√©n√©rale
                    'expected_type': 'search_and_navigate'
                },
                {
                    'prompt': "Bonjour, comment allez-vous ?",
                    'expected_navigation': False,
                    'expected_type': None
                }
            ]
            
            detection_results = []
            successful_detections = 0
            
            for test_case in test_cases:
                prompt = test_case['prompt']
                expected_nav = test_case['expected_navigation']
                expected_type = test_case['expected_type']
                
                detection = detect_navigation_need(prompt)
                
                requires_nav = detection.get('requires_navigation', False)
                nav_type = detection.get('navigation_type')
                confidence = detection.get('confidence', 0)
                
                # V√©rifier si la d√©tection correspond aux attentes
                detection_correct = (requires_nav == expected_nav)
                if expected_nav and nav_type != expected_type:
                    # Permettre une certaine flexibilit√© dans les types
                    if not (expected_type == 'search_and_navigate' and nav_type == 'search_and_navigate'):
                        detection_correct = False
                
                if detection_correct:
                    successful_detections += 1
                    status = "‚úÖ"
                else:
                    status = "‚ùå"
                
                detection_results.append({
                    'prompt': prompt,
                    'expected_navigation': expected_nav,
                    'detected_navigation': requires_nav,
                    'expected_type': expected_type,
                    'detected_type': nav_type,
                    'confidence': confidence,
                    'correct': detection_correct,
                    'status': status
                })
                
                logger.info(f"  {status} '{prompt[:50]}...' ‚Üí Nav: {requires_nav}, Type: {nav_type}, Conf: {confidence:.2f}")
            
            success_rate = (successful_detections / len(test_cases)) * 100
            overall_success = success_rate >= 70  # Au moins 70% de r√©ussite
            
            self.log_test_result("D√©tection Navigation", overall_success, 
                               f"Taux de r√©ussite: {success_rate:.1f}% ({successful_detections}/{len(test_cases)})",
                               {'results': detection_results, 'success_rate': success_rate})
            
            return detection_results
            
        except Exception as e:
            self.log_test_result("Test D√©tection", False, f"Erreur: {str(e)}")
            return None
    
    def test_web_extraction(self):
        """Test 4: Tester l'extraction de contenu web"""
        logger.info("üåê Test 4: Extraction de Contenu Web")
        
        try:
            from advanced_web_navigator import extract_website_content
            
            # URLs de test
            test_urls = [
                "https://httpbin.org/json",
                "https://httpbin.org/html",
            ]
            
            extraction_results = []
            successful_extractions = 0
            
            for url in test_urls:
                logger.info(f"  üîç Test extraction: {url}")
                
                start_time = time.time()
                content = extract_website_content(url)
                extraction_time = time.time() - start_time
                
                if content.success:
                    successful_extractions += 1
                    status = "‚úÖ"
                    details = {
                        'title': content.title,
                        'content_length': len(content.cleaned_text),
                        'quality_score': content.content_quality_score,
                        'language': content.language,
                        'links_count': len(content.links),
                        'images_count': len(content.images),
                        'keywords': content.keywords[:5],
                        'extraction_time': extraction_time
                    }
                else:
                    status = "‚ùå"
                    details = {'error': content.error_message}
                
                extraction_results.append({
                    'url': url,
                    'success': content.success,
                    'details': details,
                    'status': status
                })
                
                logger.info(f"    {status} Temps: {extraction_time:.2f}s, "
                          f"Contenu: {len(content.cleaned_text) if content.success else 0} chars, "
                          f"Qualit√©: {content.content_quality_score if content.success else 0:.1f}")
                
                time.sleep(1)  # D√©lai entre les requ√™tes
            
            success_rate = (successful_extractions / len(test_urls)) * 100
            overall_success = success_rate >= 80  # Au moins 80% de r√©ussite
            
            self.log_test_result("Extraction Web", overall_success,
                               f"Taux de r√©ussite: {success_rate:.1f}% ({successful_extractions}/{len(test_urls)})",
                               {'results': extraction_results})
            
            return extraction_results
            
        except Exception as e:
            self.log_test_result("Test Extraction Web", False, f"Erreur: {str(e)}")
            return None
    
    def test_gemini_integration_full(self, gemini_api):
        """Test 5: Test complet d'int√©gration avec Gemini"""
        logger.info("üöÄ Test 5: Int√©gration Compl√®te avec Gemini")
        
        if not gemini_api:
            self.log_test_result("Test Int√©gration Compl√®te", False, "API Gemini non disponible")
            return
        
        try:
            # Test de requ√™tes avec navigation
            test_prompts = [
                "Recherche des informations sur l'intelligence artificielle",
                "Qu'est-ce que Python ?",
                "Extrait le contenu de https://httpbin.org/json"
            ]
            
            integration_results = []
            successful_responses = 0
            
            for prompt in test_prompts:
                logger.info(f"  ü§ñ Test Gemini: '{prompt}'")
                
                try:
                    start_time = time.time()
                    
                    # Tester avec l'API Gemini modifi√©e (utilise la m√©thode fallback pour les tests)
                    response = gemini_api._fallback_get_response(
                        prompt=prompt,
                        user_id=1,
                        session_id="test_session"
                    )
                    
                    processing_time = time.time() - start_time
                    
                    # V√©rifier la r√©ponse
                    if response and 'response' in response:
                        successful_responses += 1
                        status = "‚úÖ"
                        
                        # V√©rifier si la navigation a √©t√© utilis√©e
                        response_text = response['response']
                        navigation_used = any(indicator in response_text.lower() for indicator in [
                            'navigation web', 'recherche web', 'contenu extrait', 
                            'sites web', 'pages visit√©es', 'navigation'
                        ])
                        
                        result_details = {
                            'response_length': len(response_text),
                            'navigation_used': navigation_used,
                            'processing_time': processing_time,
                            'status': response.get('status', 'unknown'),
                            'has_emotional_state': 'emotional_state' in response
                        }
                        
                        logger.info(f"    ‚úÖ R√©ponse re√ßue: {len(response_text)} chars, "
                                  f"Navigation: {'Oui' if navigation_used else 'Non'}, "
                                  f"Temps: {processing_time:.2f}s")
                    else:
                        status = "‚ùå"
                        result_details = {'error': 'Pas de r√©ponse re√ßue'}
                        logger.info(f"    ‚ùå Pas de r√©ponse re√ßue")
                    
                    integration_results.append({
                        'prompt': prompt,
                        'success': response is not None,
                        'details': result_details,
                        'status': status
                    })
                    
                except Exception as e:
                    logger.error(f"    ‚ùå Erreur pour '{prompt}': {str(e)}")
                    integration_results.append({
                        'prompt': prompt,
                        'success': False,
                        'details': {'error': str(e)},
                        'status': "‚ùå"
                    })
                
                time.sleep(2)  # D√©lai entre les requ√™tes Gemini
            
            success_rate = (successful_responses / len(test_prompts)) * 100
            overall_success = success_rate >= 70  # Au moins 70% de r√©ussite
            
            self.log_test_result("Int√©gration Compl√®te Gemini", overall_success,
                               f"Taux de r√©ussite: {success_rate:.1f}% ({successful_responses}/{len(test_prompts)})",
                               {'results': integration_results})
            
            return integration_results
            
        except Exception as e:
            self.log_test_result("Test Int√©gration Compl√®te", False, f"Erreur: {str(e)}")
            return None
    
    def test_api_endpoints(self):
        """Test 6: Tester les endpoints de l'API REST"""
        logger.info("üåê Test 6: Endpoints API REST")
        
        try:
            from web_navigation_api import register_web_navigation_api, initialize_web_navigation_api
            from flask import Flask
            
            # Cr√©er une app Flask de test
            app = Flask(__name__)
            register_web_navigation_api(app)
            initialize_web_navigation_api()
            
            endpoint_results = []
            successful_endpoints = 0
            
            with app.test_client() as client:
                # Test des endpoints principaux
                endpoints_to_test = [
                    ('GET', '/api/web-navigation/health', None, 'Health Check'),
                    ('GET', '/api/web-navigation/docs', None, 'Documentation'),
                    ('GET', '/api/web-navigation/stats', None, 'Statistiques'),
                    ('POST', '/api/web-navigation/create-session', {'user_id': 'test_user'}, 'Cr√©ation Session'),
                ]
                
                for method, endpoint, data, description in endpoints_to_test:
                    logger.info(f"  üîó Test {method} {endpoint}")
                    
                    try:
                        if method == 'GET':
                            response = client.get(endpoint)
                        elif method == 'POST':
                            response = client.post(endpoint, json=data)
                        
                        success = response.status_code == 200
                        if success:
                            successful_endpoints += 1
                            status = "‚úÖ"
                            
                            try:
                                json_data = response.get_json()
                                response_details = {
                                    'status_code': response.status_code,
                                    'has_json': json_data is not None,
                                    'content_length': len(response.data)
                                }
                                if json_data and 'success' in json_data:
                                    response_details['api_success'] = json_data['success']
                            except:
                                response_details = {
                                    'status_code': response.status_code,
                                    'content_length': len(response.data)
                                }
                        else:
                            status = "‚ùå"
                            response_details = {
                                'status_code': response.status_code,
                                'error': f"HTTP {response.status_code}"
                            }
                        
                        endpoint_results.append({
                            'method': method,
                            'endpoint': endpoint,
                            'description': description,
                            'success': success,
                            'details': response_details,
                            'status': status
                        })
                        
                        logger.info(f"    {status} {description}: HTTP {response.status_code}")
                        
                    except Exception as e:
                        logger.error(f"    ‚ùå Erreur {description}: {str(e)}")
                        endpoint_results.append({
                            'method': method,
                            'endpoint': endpoint,
                            'description': description,
                            'success': False,
                            'details': {'error': str(e)},
                            'status': "‚ùå"
                        })
            
            success_rate = (successful_endpoints / len(endpoints_to_test)) * 100
            overall_success = success_rate >= 75  # Au moins 75% de r√©ussite
            
            self.log_test_result("API REST Endpoints", overall_success,
                               f"Taux de r√©ussite: {success_rate:.1f}% ({successful_endpoints}/{len(endpoints_to_test)})",
                               {'results': endpoint_results})
            
            return endpoint_results
            
        except Exception as e:
            self.log_test_result("Test API Endpoints", False, f"Erreur: {str(e)}")
            return None
    
    def test_performance_benchmark(self):
        """Test 7: Benchmark de performance"""
        logger.info("‚ö° Test 7: Benchmark de Performance")
        
        try:
            from advanced_web_navigator import extract_website_content
            
            # Test avec plusieurs URLs pour mesurer les performances
            test_urls = [
                "https://httpbin.org/json",
                "https://httpbin.org/html",
                "https://httpbin.org/robots.txt"
            ]
            
            performance_results = []
            total_time = 0
            successful_requests = 0
            
            logger.info(f"  üìä Test de performance sur {len(test_urls)} URLs")
            
            overall_start = time.time()
            
            for i, url in enumerate(test_urls, 1):
                logger.info(f"  {i}/{len(test_urls)} Test: {url}")
                
                start_time = time.time()
                content = extract_website_content(url)
                end_time = time.time()
                
                request_time = end_time - start_time
                total_time += request_time
                
                if content.success:
                    successful_requests += 1
                    status = "‚úÖ"
                    details = {
                        'processing_time': request_time,
                        'content_length': len(content.cleaned_text),
                        'quality_score': content.content_quality_score,
                        'extraction_rate': len(content.cleaned_text) / request_time if request_time > 0 else 0
                    }
                else:
                    status = "‚ùå"
                    details = {
                        'processing_time': request_time,
                        'error': content.error_message
                    }
                
                performance_results.append({
                    'url': url,
                    'success': content.success,
                    'details': details,
                    'status': status
                })
                
                logger.info(f"    {status} Temps: {request_time:.2f}s")
                
                time.sleep(0.5)  # Petit d√©lai entre les requ√™tes
            
            overall_time = time.time() - overall_start
            
            # Calculer les m√©triques de performance
            avg_time_per_request = total_time / len(test_urls)
            success_rate = (successful_requests / len(test_urls)) * 100
            
            performance_metrics = {
                'total_requests': len(test_urls),
                'successful_requests': successful_requests,
                'success_rate': success_rate,
                'total_time': total_time,
                'overall_time': overall_time,
                'avg_time_per_request': avg_time_per_request,
                'requests_per_second': len(test_urls) / overall_time if overall_time > 0 else 0
            }
            
            # Crit√®res de performance acceptables
            performance_ok = (
                avg_time_per_request < 10.0 and  # Moins de 10s par requ√™te
                success_rate >= 70              # Au moins 70% de r√©ussite
            )
            
            logger.info(f"  üìà M√©triques de performance:")
            logger.info(f"    - Temps moyen par requ√™te: {avg_time_per_request:.2f}s")
            logger.info(f"    - Taux de r√©ussite: {success_rate:.1f}%")
            logger.info(f"    - Requ√™tes par seconde: {performance_metrics['requests_per_second']:.2f}")
            
            self.log_test_result("Benchmark Performance", performance_ok,
                               f"Temps moyen: {avg_time_per_request:.2f}s, R√©ussite: {success_rate:.1f}%",
                               {'metrics': performance_metrics, 'results': performance_results})
            
            return performance_metrics
            
        except Exception as e:
            self.log_test_result("Test Performance", False, f"Erreur: {str(e)}")
            return None
    
    def generate_test_report(self):
        """G√©n√®re un rapport de test complet"""
        logger.info("üìã G√©n√©ration du rapport de test")
        
        # Calculer les statistiques g√©n√©rales
        success_rate = (self.passed_tests / self.total_tests * 100) if self.total_tests > 0 else 0
        
        # Cr√©er le rapport
        report = {
            'test_summary': {
                'timestamp': datetime.now().isoformat(),
                'total_tests': self.total_tests,
                'passed_tests': self.passed_tests,
                'failed_tests': self.total_tests - self.passed_tests,
                'success_rate': success_rate,
                'overall_status': 'PASSED' if success_rate >= 70 else 'FAILED'
            },
            'test_results': self.test_results,
            'errors': self.errors
        }
        
        # Sauvegarder le rapport JSON
        report_file = self.test_dir / f"gemini_web_navigation_test_report_{int(time.time())}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        # Cr√©er un rapport markdown lisible
        md_report = self._create_markdown_report(report)
        md_file = self.test_dir / f"gemini_web_navigation_test_report_{int(time.time())}.md"
        with open(md_file, 'w', encoding='utf-8') as f:
            f.write(md_report)
        
        logger.info(f"üìÑ Rapport sauvegard√©: {report_file}")
        logger.info(f"üìÑ Rapport markdown: {md_file}")
        
        return report
    
    def _create_markdown_report(self, report):
        """Cr√©e un rapport markdown"""
        summary = report['test_summary']
        
        md = f"""# Rapport de Test - Syst√®me Navigation Web Avanc√© avec Gemini

## R√©sum√©
- **Date du test**: {summary['timestamp'][:19]}
- **Tests totaux**: {summary['total_tests']}
- **Tests r√©ussis**: {summary['passed_tests']}
- **Tests √©chou√©s**: {summary['failed_tests']}
- **Taux de r√©ussite**: {summary['success_rate']:.1f}%
- **Statut global**: {summary['overall_status']}

## D√©tail des Tests

"""
        
        for test_name, result in report['test_results'].items():
            status = "‚úÖ R√âUSSI" if result['success'] else "‚ùå √âCHOU√â"
            md += f"### {test_name}\n"
            md += f"**Statut**: {status}\n"
            md += f"**Message**: {result['message']}\n"
            
            if result.get('data'):
                md += f"**Donn√©es**: Voir le fichier JSON pour les d√©tails\n"
            
            md += "\n"
        
        if report['errors']:
            md += "## Erreurs Rencontr√©es\n\n"
            for error in report['errors']:
                md += f"- {error}\n"
        
        md += f"""
## Recommandations

### Statut Global: {summary['overall_status']}

"""
        
        if summary['success_rate'] >= 90:
            md += "üéâ **EXCELLENT** - Le syst√®me fonctionne parfaitement avec Gemini !\n"
        elif summary['success_rate'] >= 70:
            md += "üëç **BON** - Le syst√®me fonctionne bien avec quelques am√©liorations possibles.\n"
        elif summary['success_rate'] >= 50:
            md += "‚ö†Ô∏è **MOYEN** - Le syst√®me fonctionne partiellement, v√©rifications n√©cessaires.\n"
        else:
            md += "üö® **PROBL√àME** - Le syst√®me n√©cessite des corrections importantes.\n"
        
        return md
    
    def run_all_tests(self):
        """Lance tous les tests"""
        logger.info("üöÄ D√âMARRAGE DES TESTS COMPLETS")
        logger.info("=" * 60)
        
        start_time = time.time()
        
        try:
            # Test 1: Imports
            imported_modules = self.test_module_imports()
            
            # Test 2: Initialisation Gemini
            gemini_api = self.test_gemini_api_initialization()
            
            # Test 3: D√©tection de navigation
            self.test_navigation_detection(gemini_api)
            
            # Test 4: Extraction web
            self.test_web_extraction()
            
            # Test 5: Int√©gration compl√®te avec Gemini
            self.test_gemini_integration_full(gemini_api)
            
            # Test 6: API REST
            self.test_api_endpoints()
            
            # Test 7: Performance
            self.test_performance_benchmark()
            
        except Exception as e:
            logger.error(f"Erreur lors des tests: {str(e)}")
            self.log_test_result("Ex√©cution Globale", False, f"Erreur critique: {str(e)}")
        
        total_time = time.time() - start_time
        
        # G√©n√©rer le rapport
        report = self.generate_test_report()
        
        # Afficher le r√©sum√© final
        logger.info("=" * 60)
        logger.info("üèÅ TESTS TERMIN√âS")
        logger.info(f"‚è±Ô∏è Temps total: {total_time:.2f}s")
        logger.info(f"üìä R√©sultats: {self.passed_tests}/{self.total_tests} tests r√©ussis ({report['test_summary']['success_rate']:.1f}%)")
        
        if report['test_summary']['overall_status'] == 'PASSED':
            logger.info("üéâ TOUS LES TESTS PRINCIPAUX SONT PASS√âS !")
            logger.info("‚úÖ Le syst√®me de navigation web fonctionne avec Gemini")
        else:
            logger.info("‚ö†Ô∏è Certains tests ont √©chou√©")
            logger.info("üîß V√©rifiez les erreurs dans le rapport de test")
        
        logger.info("=" * 60)
        
        return report

def main():
    """Fonction principale"""
    print("üß™ TEST COMPLET - Syst√®me Navigation Web Avanc√© avec Gemini")
    print("=" * 70)
    print(f"üïê D√©marr√© le: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)
    
    # Cr√©er le testeur
    tester = GeminiWebNavigationTester()
    
    try:
        # Lancer tous les tests
        report = tester.run_all_tests()
        
        # R√©sultat final
        if report['test_summary']['overall_status'] == 'PASSED':
            print("\nüéä SUCC√àS COMPLET !")
            print("‚úÖ Le syst√®me de navigation web fonctionne parfaitement avec Gemini")
            print("üöÄ Vous pouvez maintenant utiliser les nouvelles capacit√©s de navigation")
            return True
        else:
            print("\n‚ö†Ô∏è TESTS PARTIELLEMENT R√âUSSIS")
            print("üîß Certaines fonctionnalit√©s n√©cessitent des ajustements")
            print("üìã Consultez le rapport de test pour plus de d√©tails")
            return False
            
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Tests interrompus par l'utilisateur")
        return False
    except Exception as e:
        print(f"\n‚ùå Erreur critique lors des tests: {str(e)}")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
